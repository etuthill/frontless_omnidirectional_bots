%check github

function [v] = agent_velocity(N, p, v, p_leader, v_leader, num_agents)

% parameter definition
k_c = 0.05;     % cohesion
k_a = 0.1;      % alignment
k_s = 0.2;      % separation

% Leader-following
k_p = 0.05;     % attraction to leader position - reduce!
k_v = 0.02;     % attraction to leader velocity - reduce!

% Avoidance
r_0 = 0.6;       % triggers earlier
k_avoid = 5.0;   % makes repulsion significantly stronger

% preallocation
F_cohesion = zeros(num_agents, 2);
F_alignment = zeros(num_agents, 2);
F_separation = zeros(num_agents, 2);
F_leader = zeros(num_agents, 2);

for i = 1:num_agents
    if sum(N(i)) == 0
        % no neighbors: only follow leader
        v(i, :) = k_p * (p_leader - p(i,:)) + k_v * (v_leader - v(i,:));
        continue;
    end
    for j = 1:length(N(i))
        if sum(N(i)) > 0 && N(i, j) ~= 0
            % cohesion force on each agent (i) from neighbors (j)
            F_cohesion(i, :) = F_cohesion(i, :) +k_c*(1/sum(N(i)) * p(j,:) - p(i,:));
            
            % alignment force on each agent (i) from neighbors (j)
            F_alignment(i, :) = F_alignment(i, :) + k_a * (1/sum(N(i)) * v(j,:) - v(i,:));
            
            % separation force on each agent (i) from neighbors (j)
            r_vec = p(i,:) - p(j,:);
            r = norm(r_vec);
            F_separation(i,:) = k_s * (r_vec / r) * log(1 + r_0 / r);
            
            % force on each agent (i) from leader
            r_vec = p(i,:) - p_leader;
            r = norm(r_vec);  % distance between the particle and the leader
            
            % logarithmic repulsive force
            if r < r_0
                F_avoid = k_avoid * (r_vec / r) * log(1 + r_0 / r);  % Soft repulsion
            else
                F_avoid = [0, 0];  % no force if not too close
            end
            
            % update leader-following force
            max_leader_force = 0.3;  % upper bound on attractive force to leader
F_attract = k_p * (p_leader - p(i,:)) + k_v * (v_leader - v(i,:));
if norm(F_attract) > max_leader_force
    F_attract = F_attract / norm(F_attract) * max_leader_force;
end

            F_leader(i, :) = F_leader(i, :) + k_p * (p_leader - p(i,:)) + k_v * (v_leader - v(i,:)) + F_avoid;
                        
            
        end
        % handle cases where distance from swarm is too great (N = 0)
    end
    % velocity on each agent (i)
    v(i, :) = F_cohesion(i, :) + F_alignment(i, :) + F_separation(i, :) + F_leader(i, :);
end
% Parameters:

% Cohesion:
% k_c = cohesion force constant (int)
% N = number of neighbors (mx)
% p = agent position (mx)

% Alignment 
% k_a = alignment force constant (int)
% N = number of neighbors (mx)
% v = agent velocity (mx)

% Separation: 
% k_s = separation force constant (int)
% p = agent position (mx)

% Leader:
% k_p = position following force constant (int)
% k_v = velocity following force constant (int)
% p_leader = leader position (vec)
% v_leader = leader velocity (vec)
% p = agent position (mx)
% v = agent velocity (mx)

% Forces:
% F_cohesion = cohesion force (pull) (mx)
% F_alignment = alignment force (pull) (mx)
% F_separation = separation force (push) (mx)
% F_leader = force relating agent to leader (pull) (mx)